package generator

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestGenerator_Generate(t *testing.T) {
	// Use comprehensive test file covering all type scenarios
	data, err := os.ReadFile("../../testdata/test.toml")
	require.NoError(t, err, "failed to read test file")

	gen := New(WithPackageName("config"))
	output, err := gen.Generate(data)
	require.NoError(t, err, "Generate() should not error")

	outputStr := string(output)

	// Ensure it's valid Go (format.Source was called)
	require.True(t, strings.HasPrefix(outputStr, "// Code generated by cfgx. DO NOT EDIT."), "output missing generation comment")

	// Check package declaration
	require.Contains(t, outputStr, "package config", "output missing package declaration")

	// Test basic types (from server config)
	require.Contains(t, outputStr, "type ServerConfig struct", "output missing ServerConfig struct")
	require.Contains(t, outputStr, "var (", "output missing var block")
	require.Contains(t, outputStr, "Server = ServerConfig", "output missing Server variable")
	require.Contains(t, outputStr, `":8080"`, "output missing Addr value")
	require.True(t, strings.Contains(outputStr, "Timeout:") && strings.Contains(outputStr, "30"), "output missing Timeout value")
	require.True(t, strings.Contains(outputStr, "Debug:") && strings.Contains(outputStr, "true"), "output missing Debug value")

	// Test nested structures (database.pool)
	require.Contains(t, outputStr, "type DatabaseConfig struct", "output missing DatabaseConfig struct")
	require.Contains(t, outputStr, "type DatabasePoolConfig struct", "output missing nested DatabasePoolConfig struct")
	require.Contains(t, outputStr, "Pool", "output missing Pool field")
	require.Contains(t, outputStr, "DatabasePoolConfig", "output missing DatabasePoolConfig type")

	// Test deeply nested structures (app.logging.rotation)
	require.Contains(t, outputStr, "type AppConfig struct", "output missing AppConfig struct")
	require.Contains(t, outputStr, "type AppLoggingConfig struct", "output missing AppLoggingConfig struct")
	require.Contains(t, outputStr, "type AppLoggingRotationConfig struct", "output missing deeply nested rotation struct")
	require.Contains(t, outputStr, "Rotation", "output missing Rotation field")

	// Test array types
	require.Contains(t, outputStr, "AllowedOrigins", "output missing AllowedOrigins field")
	require.Contains(t, outputStr, "[]string", "output missing []string type")
	require.Contains(t, outputStr, "Ports", "output missing Ports field")
	require.Contains(t, outputStr, "[]int64", "output missing []int64 type")
	require.Contains(t, outputStr, `[]string{"https://example.com", "https://app.example.com"}`, "output missing string array values")
	require.Contains(t, outputStr, "[]int64{8080, 8081, 8082}", "output missing int array values")

	// Test array of tables
	require.Contains(t, outputStr, "type EndpointsItem struct", "output missing array of tables struct")
	require.Contains(t, outputStr, "type FeaturesItem struct", "output missing features array of tables struct")
	require.True(t, strings.Contains(outputStr, "Endpoints = []EndpointsItem"), "output missing Endpoints variable")
	require.True(t, strings.Contains(outputStr, "Features = []FeaturesItem"), "output missing Features variable")

	// Verify multiple struct types were generated
	structCount := strings.Count(outputStr, "type ")
	require.GreaterOrEqual(t, structCount, 8, "expected at least 8 struct definitions for comprehensive config")
}

func TestGenerator_CustomPackageName(t *testing.T) {
	data := []byte(`
[app]
name = "test"
`)

	gen := New(WithPackageName("mypackage"))
	output, err := gen.Generate(data)
	require.NoError(t, err, "Generate() should not error")

	outputStr := string(output)
	require.Contains(t, outputStr, "package mypackage", "custom package name not applied")
}

func TestGenerator_EmptyConfig(t *testing.T) {
	data := []byte("")

	gen := New()
	output, err := gen.Generate(data)
	require.NoError(t, err, "Generate() should not error")

	// Should still generate valid Go code with just package declaration
	outputStr := string(output)
	require.Contains(t, outputStr, "package config", "empty config should still generate package declaration")
}

func TestGenerator_InvalidTOML(t *testing.T) {
	data := []byte(`
[invalid
not closed
`)

	gen := New()
	_, err := gen.Generate(data)
	require.Error(t, err, "expected error for invalid TOML")
}

func TestGenerator_DeterministicOutput(t *testing.T) {
	data := []byte(`
[zulu]
value = 1

[alpha]
value = 2

[beta]
value = 3
`)

	gen := New()

	// Generate multiple times
	output1, err := gen.Generate(data)
	require.NoError(t, err, "first Generate() should not error")

	output2, err := gen.Generate(data)
	require.NoError(t, err, "second Generate() should not error")

	// Outputs should be identical (deterministic)
	require.Equal(t, string(output1), string(output2), "generator output is not deterministic")

	// Fields should be sorted alphabetically
	out := string(output1)
	alphaPos := strings.Index(out, "\tAlpha")
	betaPos := strings.Index(out, "\tBeta")
	zuluPos := strings.Index(out, "\tZulu")

	require.NotEqual(t, -1, alphaPos, "missing Alpha variable")
	require.NotEqual(t, -1, betaPos, "missing Beta variable")
	require.NotEqual(t, -1, zuluPos, "missing Zulu variable")

	require.True(t, alphaPos < betaPos && betaPos < zuluPos, "variables not sorted alphabetically")
}

func TestGenerator_Types(t *testing.T) {
	tests := []struct {
		name string
		toml string
		want []string
	}{
		{
			name: "string type",
			toml: `[config]
value = "hello"`,
			want: []string{"Value", "string", `Value: "hello"`},
		},
		{
			name: "int type",
			toml: `[config]
value = 42`,
			want: []string{"Value", "int64", "Value: 42"},
		},
		{
			name: "float type",
			toml: `[config]
value = 3.14`,
			want: []string{"Value", "float64", "Value: 3.14"},
		},
		{
			name: "bool type",
			toml: `[config]
value = true`,
			want: []string{"Value", "bool", "Value: true"},
		},
		{
			name: "string array",
			toml: `[config]
values = ["a", "b", "c"]`,
			want: []string{"Values", "[]string", `[]string{"a", "b", "c"}`},
		},
		{
			name: "int array",
			toml: `[config]
values = [1, 2, 3]`,
			want: []string{"Values", "[]int64", "[]int64{1, 2, 3}"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New()
			output, err := gen.Generate([]byte(tt.toml))
			require.NoError(t, err, "Generate() should not error")

			outputStr := string(output)
			for _, want := range tt.want {
				require.Contains(t, outputStr, want, "output missing expected string")
			}
		})
	}
}

func TestGenerator_DurationTypes(t *testing.T) {
	tests := []struct {
		name string
		toml string
		want []string
	}{
		{
			name: "simple duration - seconds",
			toml: `[config]
timeout = "30s"`,
			want: []string{"Timeout", "time.Duration", "30 * time.Second", "import \"time\""},
		},
		{
			name: "simple duration - milliseconds",
			toml: `[config]
timeout = "500ms"`,
			want: []string{"Timeout", "time.Duration", "500 * time.Millisecond", "import \"time\""},
		},
		{
			name: "simple duration - minutes",
			toml: `[config]
timeout = "5m"`,
			want: []string{"Timeout", "time.Duration", "5 * time.Minute", "import \"time\""},
		},
		{
			name: "simple duration - hours",
			toml: `[config]
timeout = "2h"`,
			want: []string{"Timeout", "time.Duration", "2 * time.Hour", "import \"time\""},
		},
		{
			name: "zero duration",
			toml: `[config]
timeout = "0s"`,
			want: []string{"Timeout", "time.Duration", "Timeout: 0", "import \"time\""},
		},
		{
			name: "complex duration - hours and minutes",
			toml: `[config]
timeout = "2h30m"`,
			want: []string{"Timeout", "time.Duration", "2*time.Hour + 30*time.Minute", "import \"time\""},
		},
		{
			name: "complex duration - minutes and seconds",
			toml: `[config]
timeout = "5m30s"`,
			want: []string{"Timeout", "time.Duration", "5*time.Minute + 30*time.Second", "import \"time\""},
		},
		{
			name: "complex duration - hours, minutes and seconds",
			toml: `[config]
timeout = "1h30m45s"`,
			want: []string{"Timeout", "time.Duration", "1*time.Hour + 30*time.Minute + 45*time.Second", "import \"time\""},
		},
		{
			name: "complex duration - seconds and milliseconds",
			toml: `[config]
timeout = "3s500ms"`,
			want: []string{"Timeout", "time.Duration", "3*time.Second + 500*time.Millisecond", "import \"time\""},
		},
		{
			name: "complex duration - full decomposition",
			toml: `[config]
timeout = "1h2m3s4ms5us6ns"`,
			want: []string{"Timeout", "time.Duration", "1*time.Hour + 2*time.Minute + 3*time.Second + 4*time.Millisecond + 5*time.Microsecond + 6*time.Nanosecond", "import \"time\""},
		},
		{
			name: "multiple durations with different formats",
			toml: `[config]
short = "500ms"
medium = "5m"
long = "2h"
complex = "1h30m"`,
			want: []string{
				"Short", "Medium", "Long", "Complex",
				"time.Duration",
				"500 * time.Millisecond",
				"5 * time.Minute",
				"2 * time.Hour",
				"1*time.Hour + 30*time.Minute",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New()
			output, err := gen.Generate([]byte(tt.toml))
			require.NoError(t, err, "Generate() should not error")

			outputStr := string(output)
			for _, want := range tt.want {
				require.Contains(t, outputStr, want, "output missing expected string: %s", want)
			}
		})
	}
}

func TestGenerator_FileEmbedding(t *testing.T) {
	tests := []struct {
		name        string
		toml        string
		inputDir    string
		maxFileSize int64
		wantType    string
		wantError   bool
		checkBytes  bool
	}{
		{
			name: "simple text file",
			toml: `[config]
content = "file:files/small.txt"`,
			inputDir:    "../../testdata",
			maxFileSize: 10 * 1024 * 1024,
			wantType:    "[]byte",
			wantError:   false,
			checkBytes:  true,
		},
		{
			name: "certificate file",
			toml: `[tls]
cert = "file:files/cert.txt"`,
			inputDir:    "../../testdata",
			maxFileSize: 10 * 1024 * 1024,
			wantType:    "[]byte",
			wantError:   false,
			checkBytes:  true,
		},
		{
			name: "binary file",
			toml: `[data]
binary = "file:files/binary.dat"`,
			inputDir:    "../../testdata",
			maxFileSize: 10 * 1024 * 1024,
			wantType:    "[]byte",
			wantError:   false,
			checkBytes:  true,
		},
		{
			name: "file not found",
			toml: `[config]
content = "file:files/nonexistent.txt"`,
			inputDir:    "../../testdata",
			maxFileSize: 10 * 1024 * 1024,
			wantError:   true,
		},
		{
			name: "file exceeds size limit",
			toml: `[config]
content = "file:files/small.txt"`,
			inputDir:    "../../testdata",
			maxFileSize: 10, // Very small limit
			wantError:   true,
		},
		{
			name: "multiple files in struct",
			toml: `[files]
file1 = "file:files/small.txt"
file2 = "file:files/binary.dat"`,
			inputDir:    "../../testdata",
			maxFileSize: 10 * 1024 * 1024,
			wantType:    "[]byte",
			wantError:   false,
			checkBytes:  true,
		},
		{
			name: "file in nested struct",
			toml: `[app.config]
content = "file:files/small.txt"`,
			inputDir:    "../../testdata",
			maxFileSize: 10 * 1024 * 1024,
			wantType:    "[]byte",
			wantError:   false,
			checkBytes:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New(
				WithInputDir(tt.inputDir),
				WithMaxFileSize(tt.maxFileSize),
			)
			output, err := gen.Generate([]byte(tt.toml))

			if tt.wantError {
				require.Error(t, err, "Generate() should error")
				return
			}

			require.NoError(t, err, "Generate() should not error")
			outputStr := string(output)

			if tt.wantType != "" {
				require.Contains(t, outputStr, tt.wantType, "output missing type")
			}

			if tt.checkBytes {
				// Verify byte array format
				require.Contains(t, outputStr, "[]byte{", "output missing byte array")
				require.Contains(t, outputStr, "0x", "output missing hex format")
			}
		})
	}
}

func TestGenerator_FileEmbeddingByteFormat(t *testing.T) {
	// Test that byte arrays are formatted correctly
	toml := `[config]
content = "file:files/binary.dat"`

	gen := New(
		WithInputDir("../../testdata"),
		WithMaxFileSize(10*1024*1024),
	)
	output, err := gen.Generate([]byte(toml))
	require.NoError(t, err, "Generate() should not error")

	outputStr := string(output)

	// Check for proper hex format
	require.Contains(t, outputStr, "0x00", "should contain first byte (0x00)")
	require.Contains(t, outputStr, "0xff", "should contain byte 0xff")
	require.Contains(t, outputStr, "0x0f", "should contain byte 0x0f")

	// Verify proper formatting (12 bytes per line)
	require.Contains(t, outputStr, "[]byte{", "should have byte array opening")
	require.Contains(t, outputStr, "Content []byte", "should have []byte field type")

	// Read the actual file to verify byte count
	expectedContent, err := os.ReadFile("../../testdata/files/binary.dat")
	require.NoError(t, err, "should read test file")

	// Count hex patterns in output - should match file size
	hexCount := strings.Count(outputStr, "0x")
	require.Equal(t, len(expectedContent), hexCount, "should have correct number of bytes")
}

func TestGenerator_FileEmbeddingInArrayOfTables(t *testing.T) {
	toml := `[[endpoints]]
path = "/api/v1"
cert = "file:files/small.txt"

[[endpoints]]
path = "/api/v2"
cert = "file:files/binary.dat"`

	gen := New(
		WithInputDir("../../testdata"),
		WithMaxFileSize(10*1024*1024),
	)
	output, err := gen.Generate([]byte(toml))
	require.NoError(t, err, "Generate() should not error")

	outputStr := string(output)

	// Verify structure
	require.Contains(t, outputStr, "type EndpointsItem struct", "should have struct")
	require.Contains(t, outputStr, "Cert []byte", "should have []byte field")
	require.Contains(t, outputStr, "[]EndpointsItem{", "should have array")

	// Verify both files are embedded
	require.Contains(t, outputStr, "[]byte{", "should have byte arrays")
}

func TestGenerator_FileSizeLimit(t *testing.T) {
	// Test the file size limit enforcement
	tests := []struct {
		name     string
		fileSize int64
		toml     string
		wantErr  bool
	}{
		{
			name:     "within 1KB limit",
			fileSize: 1024,
			toml: `[config]
content = "file:files/small.txt"`,
			wantErr: false,
		},
		{
			name:     "exceeds 10 byte limit",
			fileSize: 10,
			toml: `[config]
content = "file:files/small.txt"`,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New(
				WithInputDir("../../testdata"),
				WithMaxFileSize(tt.fileSize),
			)
			_, err := gen.Generate([]byte(tt.toml))

			if tt.wantErr {
				require.Error(t, err, "should error due to size limit")
				require.Contains(t, err.Error(), "exceeds max size", "error should mention size limit")
			} else {
				require.NoError(t, err, "should not error")
			}
		})
	}
}
