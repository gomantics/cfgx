package generator

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestGenerator_Generate(t *testing.T) {
	// Use comprehensive test file covering all type scenarios
	data, err := os.ReadFile("../../testdata/test.toml")
	require.NoError(t, err, "failed to read test file")

	gen := New(WithPackageName("config"))
	output, err := gen.Generate(data)
	require.NoError(t, err, "Generate() should not error")

	outputStr := string(output)

	// Ensure it's valid Go (format.Source was called)
	require.True(t, strings.HasPrefix(outputStr, "// Code generated by cfgx. DO NOT EDIT."), "output missing generation comment")

	// Check package declaration
	require.Contains(t, outputStr, "package config", "output missing package declaration")

	// Test basic types (from server config)
	require.Contains(t, outputStr, "type ServerConfig struct", "output missing ServerConfig struct")
	require.Contains(t, outputStr, "var (", "output missing var block")
	require.Contains(t, outputStr, "Server = ServerConfig", "output missing Server variable")
	require.Contains(t, outputStr, `":8080"`, "output missing Addr value")
	require.True(t, strings.Contains(outputStr, "Timeout:") && strings.Contains(outputStr, "30"), "output missing Timeout value")
	require.True(t, strings.Contains(outputStr, "Debug:") && strings.Contains(outputStr, "true"), "output missing Debug value")

	// Test nested structures (database.pool)
	require.Contains(t, outputStr, "type DatabaseConfig struct", "output missing DatabaseConfig struct")
	require.Contains(t, outputStr, "type DatabasePoolConfig struct", "output missing nested DatabasePoolConfig struct")
	require.Contains(t, outputStr, "Pool", "output missing Pool field")
	require.Contains(t, outputStr, "DatabasePoolConfig", "output missing DatabasePoolConfig type")

	// Test deeply nested structures (app.logging.rotation)
	require.Contains(t, outputStr, "type AppConfig struct", "output missing AppConfig struct")
	require.Contains(t, outputStr, "type AppLoggingConfig struct", "output missing AppLoggingConfig struct")
	require.Contains(t, outputStr, "type AppLoggingRotationConfig struct", "output missing deeply nested rotation struct")
	require.Contains(t, outputStr, "Rotation", "output missing Rotation field")

	// Test array types
	require.Contains(t, outputStr, "AllowedOrigins", "output missing AllowedOrigins field")
	require.Contains(t, outputStr, "[]string", "output missing []string type")
	require.Contains(t, outputStr, "Ports", "output missing Ports field")
	require.Contains(t, outputStr, "[]int64", "output missing []int64 type")
	require.Contains(t, outputStr, `[]string{"https://example.com", "https://app.example.com"}`, "output missing string array values")
	require.Contains(t, outputStr, "[]int64{8080, 8081, 8082}", "output missing int array values")

	// Test array of tables
	require.Contains(t, outputStr, "type EndpointsItem struct", "output missing array of tables struct")
	require.Contains(t, outputStr, "type FeaturesItem struct", "output missing features array of tables struct")
	require.True(t, strings.Contains(outputStr, "Endpoints = []EndpointsItem"), "output missing Endpoints variable")
	require.True(t, strings.Contains(outputStr, "Features = []FeaturesItem"), "output missing Features variable")

	// Verify multiple struct types were generated
	structCount := strings.Count(outputStr, "type ")
	require.GreaterOrEqual(t, structCount, 8, "expected at least 8 struct definitions for comprehensive config")
}

func TestGenerator_CustomPackageName(t *testing.T) {
	data := []byte(`
[app]
name = "test"
`)

	gen := New(WithPackageName("mypackage"))
	output, err := gen.Generate(data)
	require.NoError(t, err, "Generate() should not error")

	outputStr := string(output)
	require.Contains(t, outputStr, "package mypackage", "custom package name not applied")
}

func TestGenerator_EmptyConfig(t *testing.T) {
	data := []byte("")

	gen := New()
	output, err := gen.Generate(data)
	require.NoError(t, err, "Generate() should not error")

	// Should still generate valid Go code with just package declaration
	outputStr := string(output)
	require.Contains(t, outputStr, "package config", "empty config should still generate package declaration")
}

func TestGenerator_InvalidTOML(t *testing.T) {
	data := []byte(`
[invalid
not closed
`)

	gen := New()
	_, err := gen.Generate(data)
	require.Error(t, err, "expected error for invalid TOML")
}

func TestGenerator_DeterministicOutput(t *testing.T) {
	data := []byte(`
[zulu]
value = 1

[alpha]
value = 2

[beta]
value = 3
`)

	gen := New()

	// Generate multiple times
	output1, err := gen.Generate(data)
	require.NoError(t, err, "first Generate() should not error")

	output2, err := gen.Generate(data)
	require.NoError(t, err, "second Generate() should not error")

	// Outputs should be identical (deterministic)
	require.Equal(t, string(output1), string(output2), "generator output is not deterministic")

	// Fields should be sorted alphabetically
	out := string(output1)
	alphaPos := strings.Index(out, "\tAlpha")
	betaPos := strings.Index(out, "\tBeta")
	zuluPos := strings.Index(out, "\tZulu")

	require.NotEqual(t, -1, alphaPos, "missing Alpha variable")
	require.NotEqual(t, -1, betaPos, "missing Beta variable")
	require.NotEqual(t, -1, zuluPos, "missing Zulu variable")

	require.True(t, alphaPos < betaPos && betaPos < zuluPos, "variables not sorted alphabetically")
}

func TestGenerator_Types(t *testing.T) {
	tests := []struct {
		name string
		toml string
		want []string
	}{
		{
			name: "string type",
			toml: `[config]
value = "hello"`,
			want: []string{"Value", "string", `Value: "hello"`},
		},
		{
			name: "int type",
			toml: `[config]
value = 42`,
			want: []string{"Value", "int64", "Value: 42"},
		},
		{
			name: "float type",
			toml: `[config]
value = 3.14`,
			want: []string{"Value", "float64", "Value: 3.14"},
		},
		{
			name: "bool type",
			toml: `[config]
value = true`,
			want: []string{"Value", "bool", "Value: true"},
		},
		{
			name: "string array",
			toml: `[config]
values = ["a", "b", "c"]`,
			want: []string{"Values", "[]string", `[]string{"a", "b", "c"}`},
		},
		{
			name: "int array",
			toml: `[config]
values = [1, 2, 3]`,
			want: []string{"Values", "[]int64", "[]int64{1, 2, 3}"},
		},
		{
			name: "duration type",
			toml: `[config]
timeout = "30s"`,
			want: []string{"Timeout", "time.Duration", "30 * time.Second", "import \"time\""},
		},
		{
			name: "duration types with various formats",
			toml: `[config]
short = "500ms"
medium = "5m"
long = "2h"`,
			want: []string{"Short", "Medium", "Long", "time.Duration", "500 * time.Millisecond", "5 * time.Minute", "2 * time.Hour"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New()
			output, err := gen.Generate([]byte(tt.toml))
			require.NoError(t, err, "Generate() should not error")

			outputStr := string(output)
			for _, want := range tt.want {
				require.Contains(t, outputStr, want, "output missing expected string")
			}
		})
	}
}
